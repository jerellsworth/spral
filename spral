#!/usr/bin/env python3

"""Stupid Python RetroArch Launcher"""

import argparse
import json
import os
import platform
from dataclasses import dataclass
from pathlib import Path
from tkinter import Tk, ttk
from tkinter.filedialog import LoadFileDialog
from typing import Any, Callable, Dict, Iterable, Optional, Tuple

WINDOW_WIDTH = 800
WINDOW_HEIGHT = 600

HOME = Path.home()
ROOT = Path(HOME.anchor)
STR_HOME = str(HOME)


@dataclass
class Params:
    ra_path: Optional[Path]
    core_path: Optional[Path]
    rom_path: Optional[Path]

    def verify(self) -> bool:
        return (
            self.ra_path is not None
            and self.ra_path.is_file()
            and self.core_path is not None
            and self.core_path.is_file()
            and self.rom_path is not None
            and self.rom_path.is_file()
            )

class Config:

    @staticmethod
    def _find_longest_existing_prefix(p: Path):
        while not p.is_dir():
            p_parent = p.parent
            if p == p_parent:
                return p
            p = p_parent
        return p

    @staticmethod
    def _match_key(p: Path, file_ext: str) -> str:
        if p.is_file():
            p = p.parent
        return f"{p}:{file_ext.lstrip('.').upper()}"

    def __init__(self, path: Optional[Path] = None):
        self.path = path or (HOME / ".spral.json")
        self._init_config()

    def _save(self):
        self.path.write_text(json.dumps(self.cfg))

    def _init_config(self):
        if self.path.exists():
            self.cfg = json.loads(self.path.read_text())
            return
        if platform.system() == "Darwin":
            self.cfg = dict(
                general=dict(
                    ra_path=str(
                        ROOT
                        / "Applications"
                        / "RetroArch.app"
                        / "Contents"
                        / "MacOS"
                        / "RetroArch"
                    ),
                    last_core_picked=str(
                        HOME / "Library" / "Application Support" / "RetroArch" / "cores"
                    ),
                    last_rom_picked=str(HOME),
                ),
                matches={},
            )
        else:
            self.cfg = dict(
                general=dict(
                    ra_path=str(ROOT),
                    last_core_picked=str(HOME),
                    last_rom_picked=str(HOME),
                ),
                matches={},
            )
        self._save()

    def get_ra_path(self) -> Path:
        return Path(self.cfg["general"]["ra_path"])

    def set_ra_path(self, p: Path) -> None:
        self.cfg["general"]["ra_path"] = str(p)
        self._save()

    def get_last_core_picked(self) -> Path:
        return Path(self.cfg["general"]["last_core_picked"])

    def set_last_core_picked(self, p: Path) -> None:
        self.cfg["general"]["last_core_picked"] = str(p)
        self._save()

    def get_last_rom_picked(self) -> Path:
        return Path(self.cfg["general"]["last_rom_picked"])
        
    def set_last_rom_picked(self, p: Path) -> None:
        self.cfg["general"]["last_rom_picked"] = str(p)
        self._save()

    def get_best_core(self, p: Path, file_ext: str) -> Optional[Path]:
        core = self.cfg["matches"].get(self._match_key(p, file_ext))
        if core is None:
            return None
        return Path(core)

    def set_best_core(self, p: Path, file_ext: str, core: Path) -> None:
        self.cfg["matches"][self._match_key(p, file_ext)] = str(core)
        self._save()

    def update_from_params(self, params: Params):
        if not params.validate():
            return
        self.set_ra_path(params.ra_path)
        self.set_last_core_picked(params.core_path)
        self.set_last_rom_picked(params.rom_path)
        self.set_best_core(params.rom_path, params.rom_path.suffix, params.corer_path)
        self._save()





def get_params(rom_path: Optional[Path], cfg: Config) -> Params:
    ra_path = cfg.get_ra_path()
    if rom_path is None:
        core_path = None
    else:
        core_path = cfg.get_best_core(rom, rom.suffix)
    return Params(
        ra_path=ra_path,
        core_path=core_path,
        rom_path=rom_path
        )


def run(params: Params):
    assert params.verify(), f"Run parameters could not be verified: {params}"
    cmd = f"'{parrams.ra_path}' -L '{params.core_path}' '{params.rom_path}'"
    os.system(cmd)


def gui(params: Params, cfg: Config):
    root = Tk()
    frm = ttk.Frame(root, padding=10)
    frm.grid()
    ttk.Label(frm, text="Hello World!").grid(column=0, row=0)
    ttk.Button(frm, text="Quit", command=root.destroy).grid(column=1, row=0)
    root.mainloop()


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Launch RetroArch")
    parser.add_argument(
        "-g",
        help="Force gui",
        action="store_true",
    )
    parser.add_argument("ROM", nargs="?", default=None, type=Path)
    args = parser.parse_args()
    force_gui = args.g
    rom = args.ROM

    cfg = Config()

    params = get_params(rom, cfg)
    if (force_gui or (not params.verify())):
        params = gui(params, cfg)
        cfg.update_from_params(params)
    run(params)
